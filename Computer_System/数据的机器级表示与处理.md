# 数据的机器级表示与处理
## 1. 数制和编码 整数 浮点数
无穷大：阶码全1，尾数全0
正负零：阶码全0，尾数全0
无定义：阶码全1，尾数非0

阶码
非零(规格化): 2^exp-127^
全零(非规格化): 2^-126^
尾数真值
规格化：1.(23位)
非规格化: 0.(23位)

significand带隐藏位的
fraction不带隐藏位

max: (1-2^-24^) * 2^127^
min: 2^-129^

有权BCD码(8421码)
无权BCD码(格雷码，余3码)

小端：低有效在低地址
LSB，MSB(least significant bit)

## 2. 数据基本运算
浮点数加减无结合性  

对阶(小阶向大阶对齐)，尾数加减，尾数规格化(右规左规到1.bbbbb……)，尾数舍入，阶码溢出判断

右移对阶时留出G(保护位)R(舍入位)S(粘位，舍入位右边有非零数粘位为1)
附加位保护右移的中间结果，左移时移入significand，也作为舍入依据
Guard(保护位)：significand右边一位
Round(舍入位)：G右边一位
```c
// Kahan 累加算法
// 每次因累加舍入的截断误差保存起来，加入到下一次累加
float tem = 0.1f;
float sum = 0.1f;
float c = 0;
float y, t;
for(int i = 1; i < 4000000; i++) {
    y = tem - c;
    t = sum + y;
    c = (t - sum) - y;
    sum = t;
}
```
```
规格化 舍入
case 规格化 && sig_grs隐藏位后超过26位
    右移 exp++ 直到sig_grs >> 26 == 1
    exp上溢
case 规格化 sig_grs隐藏位后不到26位
    左移 exp-- 直到sig_grs >> 26 == 1
    exp下溢
    为配合非规格化数，额外右移一次
case 非规格化 sig_grs >> 26 == 1
    exp++
case exp < 0
    右移 exp++ 直到exp==0 && sig_grs >> 26 <= 1 && sig_grs > 0
                或exp>0 && sig_grs>>26==1
    sig_grs<=4(舍入后为0) && exp < 0 阶码下溢
```
尾数是0，需要把阶码置0
一个负数的补码等于模减该负数的绝对值
对于某一确定的模，某数减去小于模的另一数，总可以用该数加上另一数负数的补码来代替计算
1. 求阶差(Δx = x1 - x2，x1 > x2，结果阶码为x1)
2. 对阶
3. 尾数加减
4. 尾数规格化
5. 尾数舍入
6. 尾数为0，阶码置零
q1: 通过阶码差的补码计算阶差
    [ΔE]补= [Ex–Ey]~补~ = [Ex]~移~ + [–[Ey]~移~]~补~   (mod 2n)
q2: ΔE溢出时无法用q1计算
q3: IEEE 754 SP格式，|ΔE|>24时，计算结果等于大的数，小数被吃掉
```cpp
int x;
float f;
double d;
x == (int)(float) x     // 0
x == (int)(double) x    // 1
f == (float)(double) f  // 1
d == (float) d          // 0
f == -(-f);             // 1
2/3 == 2/3.0            // 0
d < 0.0 ⇒((d*2) < 0.0) //  1  
d > f ⇒ -f > -d         // 1
d * d >= 0.0            // 1
x*x>=0                  // 0
(d+f)-d == f            // 0
```
IEEE 754 加减最多只右规一次：即使是最大的尾数相加尾数和也小于4，保留隐含1后，最多一位右移到小数部分
n位带标志加法器
OF = C~n~ ^ C~n-1~
SF = F~n-1~
CF = Cout ^ Cin
A + B
AB同号，和Sum不同号，OF=1 否则OF = 0
CF = Cout ^ sub
无符号x+y溢出时：res < x && res < y
带符号x+y溢出时：x < 0 && y < 0 && res >= 0 || x >= 0 && y >= 0 && res < 0
带符号x-y溢出时：x>>31 != ~y>>31 && x>>31 != res>>31
无符号x*y溢出时：res高32位 != 0
带符号x*y溢出时：res高32位每位 = res低32位最高位
booth's algorithm
变量*常数：移位组合加减
整数除法只有-2^n-1^/-1会溢出
变量/常数：逻辑/算数右移，若不能整除，右移出的1要相应处理
```txt
     x = – 1.5 x 1038,   y = 1.5 x 1038,    z = 1.0
     (x+y)+z = (–1.5x1038+1.5x1038 ) +1.0 = 1.0
     x+(y+z) = –1.5x1038+ (1.5x1038+1.0) = 0.0
浮点数不符合加法结合律
```
```txt
位运算除法除32
int div32(int x) {
    int off = (x>>31)&0x1F;
    // 加偏移量 2^k^-1, 32 = 2^5^, k = 5
    return (x+off) >> 5;
}
```
变量常数除运算向零舍入(带符号数结果负，先纠偏(加偏移量)，再右移)
## 3. 字符
'a' = 97
'A' = 65
'1' = 49