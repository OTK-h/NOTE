# 6 层次结构存储系统
### 6.1 存储器概述
记忆单元(Cell)
>具有两种稳态的能够表示二进制数码0和1的物理器件
存储单元/编址单位(Addressing Unit) 
>具有相同地址的位构成一个存储单元，也称为一个编址单位
存储体/存储矩阵/存储阵列(Bank)
>所有存储单元构成一个存储阵列
编址方式(Addressing Mode) 
>字节编址、按字编址
存储器地址寄存器(Memory Address Register - MAR)
>用于存放主存单元地址的寄存器
存储器数据寄存器(Memory Data Register - MDR)
>用于存放主存单元中的数据的寄存器

按工作性质/存取方式分类
>随机存取存储器 Random Access Memory (RAM) 
>>每个单元读写时间一样，且与各单元所在位置无关。如：内存。
>顺序存取存储器 Sequential Access Memory (SAM)
>>数据按顺序从存储载体的始端读出或写入，因而存取时间的长短与信息所在位置有关。例如：磁带。
>直接存取存储器 Direct Access Memory(DAM)
>>直接定位到读写数据块，在读写数据块时按顺序进行。如磁盘。
>相联存储器 Associate Memory（AM）/ Content Addressed Memory (CAM)
>>按内容检索到存储位置进行读写。例如：快表。

按功能/速度/容量/位置分类
>寄存器(Register)
>>封装在CPU内，用于存放当前正在执行的指令和使用的数据
>>用触发器实现，速度快，容量小（几~几十个）
>高速缓存(Cache)
>>位于CPU内部或附近，用来存放当前要执行的局部程序段和数据
>>用SRAM实现，速度可与CPU匹配，容量小（几MB）
>内存储器MM（主存储器Main (Primary) Memory）
>>位于CPU之外，用来存放已被启动的程序及所用的数据
>>用DRAM实现，速度较快，容量较大（几GB）
>>主存地址空间大小不等于主存容量
>外存储器AM (辅助存储器Auxiliary / Secondary  Storage)
>>位于主机之外，用来存放暂不运行的程序、数据或存档文件
>>用磁盘、SSD等实现，容量大而速度慢

主存性能指标：存储容量，存取时间T~A~(写入时间，读取时间)，存储周期T~MC~(两个连续访存最短间隔，大于T~A~)

半导体存储器
>RAM
>>SRAM(static 用于Cache)
>>DRAM(dynamic 用于主存)
>ROM
>>不可在线改写的ROM
>>Flash ROM(闪存，用于BIOS)

### 6.2 主存与CPU的连接及其读写操作
总线 - 数据线+地址线+控制线
#### 6.2.1 主存芯片技术
1. DRAM芯片技术
双译码：地址译码器分X和Y两个方向
>16M bit = 4Mb * 4 = 2048 * 2048 * 4 = 2^11^ * 2^11^ * 4
>地址线十一根线在行列方向分时复用，由RAS，CAS控制时序
>需要四个位平面，行列交叉点的四位一起读写
>>新一代DRAM容量至少四倍：行列分时复用，各乘二总乘四

2. 基本SDRAM芯片技术
总线宽度：总线中数据线条数
支持突发传输(burst)，第一次存取给出首地址，以后按地址顺序读取
CPU访问一块连续区域(行地址相同)可直接从行缓冲读取(SRAM实现)
突发长度：传送数据的长度，BL
CAS潜伏期：收到读命令到开始传送的延迟，CL，又叫读取潜伏期，只有读命令有

3. DDR SDRAM芯片技术
利用芯片内部I/O缓冲数据两位预取功能，利用上升沿下降沿进行两次传输

4. DDR2 SDRAM芯片技术
在3的基础上利用四位预取

5. DDR3 SDRAM芯片技术
在3的基础上利用八位预取
##### 6.2.2 主存与CPU的连接及其读写
128MB的DRAM：4096 * 4096 * 8行列各十二位
芯片内地址不连续，交叉编址，同时读写所有芯片
主存地址27位，片内地址24位，主存地址第三位用来选片
12 12 3
行号 列号 片号
行缓冲中数据地址连续(行列相同，片号递增)
若片内地址连续，则高三位为片号

若一个2^n^ * b位DRAM芯片的存储阵列是r行×c列，则该芯片容量为2^n^ * b位且 2^n^=r*c
>16K×8位DRAM，则r=c=128
芯片内的地址位数为n，其中行地址位数为log2r，列地址位数为log2c
>16K×8位DRAM，则n=14，行、列地址各占7位
通常r <= c且 |r-c|最小
>按行刷新，且减少地址引脚
#### 6.2.3 Load Store指令过程
load
>CPU把addr和读命令送总线
>主存经过取数时间，把数据送总线
>CPU经确定时间，从总线取数

store
>CPU把addr和写命令送总线
>CPU把数据送总线(信号线不复用可和上一步同时)
>等待写入时间，主存写入

### 6.3 磁盘存储器
#### 6.3.1 磁盘存储器结构
写：将不同磁化状态记录在表面
读：磁头固定载体转动，在线圈两端得到感应电压

每个面一个磁头
磁道：磁头和盘面相对运动构成的圆
柱面：多个盘片上相同磁道
扇区：每个磁道划分(512B -> 4096B)

第i个扇面：
间隙1
ID域i：同步字节，道号，头号，段号，CRC
间隙2
数据域：同步字节，数据，CRC
间隙3

数据地址
10位   4位   11位
柱面号 磁头号 扇区号

并行数据来自总线，并串转换电路，穿行读写数据，串并转换电路，并行数据送总线

1. 寻道：地址送磁盘寄存器，移动到指定柱面，返回寻到结束信号给磁盘控制器，转入旋转等待操作
2. 旋转等待：扇区计数器清零，每过一个扇区加一，直到等于扇区地址
3. 读写：
#### 6.3.2 磁盘存储器性能指标
低密度：总容量 = 面数 * 柱面数 * 内圆周长 * 内道密度
>面数 = (外径 - 内径) / 2 * 道密度
>实际容量：2 * 盘片数 * 磁道数/面数 * 扇区数/磁道数 * 512B/扇区

响应时间 = 排队延迟 + 控制器时间 + 存取时间(寻道时间 + 旋转等待时间 + 数据传输时间)

512B扇区，转速5400RPM，寻道时间(最大寻道时间的一半)12ms，数据传输率4MB/s，控制器时间1ms，排队时间0s，求响应时间
>0 + 1ms + 12ms + 0.5/5400RPM + 0.5KB/4MB/s
>0 + 1ms + 12ms + 0.5/90RPS + 0.128/1000s
>1ms + 12ms + 5.5ms + 0.1ms
>18.6ms

每道扇区数：(4MB * 60/5400) / 512B = 87
#### 6.3.3 磁盘存储器连接
最小单位是扇区；成批数据交换
Direct Memory Access(DMA)：直接存储器存取，数据不通过CPU，DMA控制器控制总线进行DMA传送
>CPU对DMA控制器初始化(命令，磁盘逻辑块号，主存起始地址，数据块大小)，启动磁盘驱动器
>磁盘控制器读扇区，DMA方式送主存
>DMA传送结束，DMA控制器向CPU发送DMA结束中断请求
#### 6.3.4 固态硬盘
闪存(读块写慢)
>写入
>>快擦：全1
>>编程：写0
>读出：控制栅正电压，状态0检测不到电流

### 6.4 高速缓冲存储器cache
#### 6.4.1 程序访问的局部性
层次化存储器结构：空间局部性，时间局部性
>程序的空间/时间局部性：数组按行优先顺序存放，双层循环中内层放列
#### 6.4.2 Cache基本工作原理
Cache行和主存块映射
主存和Cache一个单元为2^b^字节，主存块 | Cache行(槽)
内存中第M个块在Cache中第 (M mod Cache行数) 行

e.g.
以2^b^字节大小划分块
主存有2^m^个块
Cache提供2^c个行
某数据物理地址为32位
>块号：addr >> b：地址高m位
>行号：块号 % 2^c^：地址高m位中的低c位
>标记：地址高32位除去行号(高m-c位)
>块内地址：剩余32-m=b位
Cache每一行
有效位 | 标记 | 2^b^字节块内数据
||||
|:---|:---|:---|
|标记|Cache行号|块内地址|
|高m-c位|中间c位|低b位|

1. 找到对应行号
2. 比较Cache标记和地址标记，若不想等，读取内存到Cache
3. 看有效位，false读取内存到cache
#### 6.4.3 Cache行和主存块的映射
直接映射：块到固定行
>容易实现，命中时间短，无需考虑替换，空间利用不足，命中率低
>>直接映射，块大小16B，Cache数据区容量64KB，主存地址32位按字节，求Cache多少行，容量大小，数据占比
>>行数 = 64KB/16B = 4K
>>容量 = 4K * (16+1)b + 64KB * 8 = 580kb = 72,5KB
>>占比 = 64/72.5 = 0.883
全相联映射：块到任意行
>无需Cache索引，没有冲突缺失(只要有空)，比较器个数和位数多(每行一个)
组相联映射：块到固定组的任意行
>Cache组号 = 主存块号 % Cache组数

#### 6.4.4 Cache中主存块替换算法
Hit Rate：在Cache中的概率
Hit Time：在Cache中访问时间 = 判断时间 + 访问时间
Miss Rate = 1 - Hit Rate
Miss Penalty：缺失损失，访问一个主存块所需时间
1. FIFO
>命中率不随组增大而增大
2. LRU：最近最少用
>命中率遂组增大而增大最近少用算法，增加计数值(LRU位数 = log2(每组行数))
>被访问的置零，其余加一，
>未命中且未满，新行置零，其余加一
>未命中且已满，最大的替换，同上
3. LFU：最不常用算法
>替换引用最少的行，类似LRU
4. 随机替换算法：性能稍低，代价低
#### 6.4.5 Cache一致性问题
Write Hit/Miss
读比写容易(指令Cache比数据Cache易设计)
```
Write Hit
    Write Through
        同时写主存和Cache
        使用Write Buffer
    Write Back
        只写Cache，Miss时一次写回
        每行有dirty-bit
Write Miss
    Write Allocate
        主存装入，更新
        利用空间局部性，但每次要从主存读
    Not Write Allocate
        更新，不装入
```

e.g.
Cache有64行，每块16B，求地址1200在第几行
块号 = 1200 / 16 = 75
行号 = 75 % 64 = 11

e.g.
直接映射，16K = 2^14^行，每块4B，32位主存，求Cache需要的容量
Cache包含：1位valid_bit，32-14-2位tag，4B = 32bit数据
2^14^ * (1 + 32-14-2 + 32) = 784Kbits

e.g.
若每块大小为2^m^字(4*2^m^B)
2^14^ * (1 + 32-14-2-m + 32*2^m^)

e.g.
数据在Cache和主存间传送单位512字，Cache大小2^13^字，主存大小2^20^字，如何访问0x120CH单元
Cache大小 = 2^13^字 = 8K字 = 16行 * 512字/行
主存大小 = 2^20^字 = 1024K字 = 
### 6.4.6 Cache性能
1. 单级/多级，联合/分立
一般L1Cache位分立Cache，L2为联合Cache，因为L1Cache命中时间更重要，L2Cache命中率更重要
因为缺失时从主存取数
2. 主存-总线-Cache连接结构

### 6.4.7 IA-32的Cache结构
主存与L3Cache链接，四个core每个核有L1d-Cache，L1i-Cache，L2 Cache，四个L2共享L3
### 6.4.8 Cache和程序性能
```c
int a[256][256]
for(int i = 0; i < 256; i++) {
    for(int j = 0; j < 256; j++) {
        // proc1 a[i][j]
        // proc2 a[j][i]
    }
}
```
32位及其，Cache8行，主存块64B，主存大小256MB，直接映射，a首地址320
1. 不考虑控制位，求数据Cache总容量
2. 求a[0][31]对应的主存块的Cache行号
3. 求proc1和proc2的命中率

1. 主存大小256MB->主存地址28位(6位块内地址，3位行号，标志28-6-3)，数据Cache容量8*(1+19+64*8) = 4256bit = 532B
2. a[0][31] = 320 + 4*31 = 444，444 / 64 mod 8 = 6（or 第678位，0-5位为块内地址）
a[31][0]
3. 每个主存块第一个缺失，其他命中，共访问256*256=64K次，proc1缺失4K(块数*4.64 = 256*256*4/64 = 4K)次，1-4K/64K = 93.75%，proc2每次缺失，命中率0
## 6.5 虚拟存储器
早期地址分页方式：
执行到4K大小程序段，当前贮存内容保存到磁盘，把磁盘上这4K内容读入主存，改变地址映射(mod4K)
### 6.5.1 虚拟存储器的基本概念
1. 内存分为定长的小存储块(页框，实页，物理页)
2. 进程分为定长的小程序块(页，虚页，逻辑页)
3. 程序块可以装入主存页框
4. 进程可放在不连续页框
5. OS为每个进程生成页表Page Table
6. 页表实现逻辑地址向物理地址转换

逻辑地址(虚拟地址Virtual Address)：程序指令所用地址(进程所在地址)
物理地址(Physical Address)：实际主存地址，实地址，主存地址
## 6.6 IA-32/Linux中的地址转换














用户程序可以修改自己的数据，不应该可以修改系统和自身代码
分段机制，同一种功能和访问控制类型的数据放在一起，统一提供保护
段表(全局描述符表GDT)
段名称 起始地址(Base) 界限(Limit) 权限要求(DPL)

程序访存时提供三个信息：
确定段基址：段号
检查越界情况：数据相对基址偏移量
检查权限：程序的权限等级

GDT由OS初始化，保存在内存中
GDTR寄存器保存GDT首地址和界限(长度减一)

operand_read() -> vaddr_read() -> laddr_read() -> paddr_read() -> cache_read() ->hw_mem_read() -> hw_mem[]

```
分段机制x86
    启动
        进入实模式
        加载OS
        OS初始化GDT
        进入保护模式(开启分段机制)
    启动后
        程序给出48位逻辑地址(虚拟地址)(16段选择符，32有效地址/段内偏移量)
        根据段选择符查GDT
        段级地址转换，得到线性(物理)地址
```

CR0寄存器中PE位：0实地址，1保护地址

80836保护模式地址转换：
段选择符在16位段寄存器，指向64位段描述符
CS(代码段寄存器), SS(栈段寄存器), DS(数据段寄存器), ES, FS, GS其他三个任意数据段
16位段选择符
13位index：段描述符表索引
1位TI(Table Indicator)：0表示GDT，1表示LDT
2位RPL(Requestor's Privilege Level)：00内核态，11用户态

Selector指向段描述符，Offset表示段内偏移量
由段描述符的Base，Addr和虚拟地址的Offset组成线性地址
Linear Addr：Dir | Page | Offset

32位线性地址 = 32位Base + 32位Offset

可访问：段描述符DPL >= 段选择符RPL
